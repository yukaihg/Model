
var http = require('http');

/**
 * Main connection class
 *
 */
var Connection = function(host, port) {
	port = port || 9200;
	this.agent = new http.Agent({host: host, port: port});
	this.host = host;
	this.port = port;
}

/**
 * Request utility function.
 *
 */
Connection.prototype.request = function(method, path, data, callback) {

	if (callback && typeof callback !== "function")
		throw new TypeError("Callback must be a function!");

	callback = callback || function() { }

	var req = http.request({
		host: this.host,
		port: this.port,
		path: path,
		method: method,
		agent: this.agent,
		headers: {
			Connection: "keep-alive"
		}
	}, function(response) {
		
		if (response.statusCode < 200 || response.statusCode > 300) {
			return callback(response);
		}


		var types = [ "application/json", "application/smile", "text/plain" ];
		var type = response.headers['content-type'];
		for (var i in types) {
			if (type.substring(0, types[i].length) === types[i]) {
				type = types[i];
				break;
			}
		}

		if (type == "application/json") {
			var buf = "";
			response.on("data", function(data) {
				buf += data;
			}).on("end", function(){
				var obj = JSON.parse(buf);
				callback(undefined, response, obj);
			});
		} 
		else if (type == "application/smile") {
			callback(undefined, response)
		} 
		else if (type === "text/plain") {
			var buf = "";
			response.on("data", function(data) {
				buf += data;
			}).on("end", function(){
				callback(undefined, response, buf);
			});
		}
		else {
			callback(undefined, response);
		}

	
	});

	if (data) {
		var json = JSON.stringify(data);
		req.setHeader("Content-type", "application/json; encoding=utf8");
		req.setHeader("Content-length", Buffer.byteLength(json, 'utf8'));
		req.write(json, "utf8");
	}

	req.on("error", function(err) {
		callback(err);
	})

	//console.log(req);
	return req;
}

/**
 *
 *
 */
Connection.prototype.exists = function(path, callback) {
	this.request('HEAD', path, function(err, response) {
		if (err)
			return callback(err)
		callback(undefined, response.statusCode == 200)
	}).end();
}

/**
 *
 *
 */
Connection.prototype.get = function(path, data, callback) {
	if (typeof callback === "undefined") {
		callback = data;
		data = undefined;
	}
	this.request('GET', path, data, callback).end();
	return this;
}

/**
 *
 *
 */
Connection.prototype.put = function(path, data, callback) {
	this.request('PUT', path, data, callback).end()
	return this;
}

/**
 *
 *
 */
Connection.prototype.post = function(path, data, callback) {
	this.request('POST', path, data, callback).end()
	return this;
}

/**
 *
 *
 */
Connection.prototype.delete = function(path, callback) {
	var req = this.request('DELETE', path, null, callback).end()
	return this;
}

/**
 * Describe the ES server.
 *
 */
Connection.prototype.describe = function(done) {
	this.get("/", done);
	return this;
}

/**
 * 
 *
 */
Connection.prototype.index = function(name) {
	return new Index(this, name);
}

/**
 * Close any persistent connections to the server.
 *
 */
Connection.prototype.close = function() {
	for (var i = 0; i < this.agent.sockets.length; ++i)
		this.agent.sockets[i].end();
	return this;
}

/**
 * Object representing an ES index.
 * @see http://www.elasticsearch.org/guide/appendix/glossary.html#index
 */
var Index = function(connection, name, options) {
	this.connection = connection;
	this.name = name;
}


/**
 * Create/update an index.
 * @see http://www.elasticsearch.org/guide/reference/api/admin-indices-create-index.html
 */
Index.prototype.put = function(callback) {
	//FIXME: Update the data
	this.connection.put(this.path(), {}, callback);
	return this;
}

/**
 * Check to see if an index exists.
 * 
 */
Index.prototype.exists = function(done) {
	this.connection.exists(this.path(), done);
	return this;
}

/**
 * Delete an existing index.
 * @see http://www.elasticsearch.org/guide/reference/api/admin-indices-delete-index.html
 */
Index.prototype.delete = function(done) {
	this.connection.delete(this.path(), done);
	return this;
}

/**
 * Open a previously closed index; it will go through the normal recovery process.
 * @see http://www.elasticsearch.org/guide/reference/api/admin-indices-open-close.html
 */
Index.prototype.open = function(callback) {
	this.connection.post(this.path()+"/_open", callback);
	return this;
}

/**
 *  Close an index. A closed index has almost no overhead on the cluster (except for maintaining 
 * its metadata), and is blocked for read/write operations.
 * @see http://www.elasticsearch.org/guide/reference/api/admin-indices-open-close.html
 */
Index.prototype.close = function(callback) {
	this.connection.post(this.path()+"/_close", callback);
	return this;
}

/**
 *
 *
 */
Index.prototype.mapping = function(name) {
	return new Mapping(this, name);
}

/**
 * Get the path component of the URL representing the index.
 *
 */
Index.prototype.path = function() {
	return "/"+this.name;
}

/**
 *
 *
 */
Index.prototype.describe = function(done) {
	this.connection.get(this.path()+"/_settings", done);
	return this;
}

/**
 * 
 * @see http://www.elasticsearch.org/guide/reference/api/admin-indices-aliases.html
 */
Index.prototype.alias = function(name, callback) {
	this.connection.post("/_aliases", {actions: [
		{ add: { index: this.name, alias: name }}
	]}, callback);
	return this;
}

/**
 * Search through all documents that belong to the index.
 * @see: http://www.elasticsearch.org/guide/reference/api/search/
 */
Index.prototype.search = function(query, callback) {
	this.connection.get(this.path()+"/_search", query, function(err, req, data) {
		callback(err, data);
	});
	return this;
}

/**
 *
 *
 */
var Mapping = function(index, name) {
	this.connection = index.connection;
	this.name = name;
	this.index = index;
}

/**
 *
 *
 */
Mapping.prototype.exists = function(done) {
	this.connection.exists(this.path(), done);
	return this;
}



/**
 *
 *
 */
Mapping.prototype.path = function() {
	return this.index.path() + "/" + this.name;
}

/**
 *
 * @see http://www.elasticsearch.org/guide/reference/api/admin-indices-get-mapping.html
 */
Mapping.prototype.describe = function(done) {
	this.connection.get(this.path() + "/_mapping", done);
	return this;
}

/**
 *
 * @see http://www.elasticsearch.org/guide/reference/api/admin-indices-put-mapping.html
 */
Mapping.prototype.put = function(done) {
	this.connection.put(this.path() + "/_mapping", { }, done);
	return this;
}

/**
 *
 * @see http://www.elasticsearch.org/guide/reference/api/admin-indices-delete-mapping.html
 */
Mapping.prototype.delete = function(done) {
	this.connection.delete(this.path(), done);
	return this;
}


/**
 *
 *
 */
Mapping.prototype.document = function(name, data, callback) {
	var doc = new Document(this, name);
	if (data)
		doc.set(data, callback);
	return doc;
}

/**
 * Search for all documents that belong to the mapping.
 * @see http://www.elasticsearch.org/guide/reference/api/search/
 */
Mapping.prototype.search = function(query, callback) {
	this.connection.get(this.path()+"/_search", query, function(err, req, data) {
		callback(err, data);
	});
	return this;
}

/**
 * Represents a document within the database.
 *
 */
var Document = function(mapping, id) {
	this.connection = mapping.connection;
	this.mapping = mapping;
	this.id = id;
}

/**
 * Check to see if a document with a given id exists.
 *
 */
Document.prototype.exists = function(done) {
	this.connection.get(this.path()+"?fields=", function(err, result) {
		if (err)
			return done(err);
		done(undefined, result.exists);
	})
	return this;
}

/**
 * 
 *
 */
Document.prototype.set = function(data, callback) {
	var self = this;
	if (this.id) {
		this.connection.put(this.path(), data, callback);
	}
	else {
		this.connection.post(this.path(true), data, function(err, response, result) {
			if (err)
				return callback(err)
			self.id = result._id;
			callback(result);
		});
	}
	return this;
	
}

/**
 *
 *
 */
Document.prototype.get = function(callback) {
	this.connection.get(this.path(), function(err, response, data) {
		callback(err, data);
	});
	return this;
}

/**
 * Remove a document from the database.
 *
 */
Document.prototype.delete = function(callback) {
	this.connection.delete(this.path(), callback);
	return this;
}

/**
 *
 *
 */
Document.prototype.path = function(noIdAllowed) {
	if (!noIdAllowed && !this.id)
		throw new Error("Document needs an id!");
	return this.mapping.path() + "/" + (this.id || "");
}

/**
 * Exposed functionality
 *
 */
exports.createClient = exports.connect = function(host, port) {
	return new Connection(host, port);
}

exports.defaultPort = 9200;
